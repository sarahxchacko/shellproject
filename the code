#include<stdio.h> 
#include<stdlib.h>
#include<string.h> 
#include<unistd.h>
#include<sys/wait.h> 

//uncomment if getline doesn't work on your machine: 
//#define _GNU_SOURCE

#define DEL "\n\t \v\f\r" //all types of whitespaces 

//uncomment if getline doesn't work on your machine: 
ssize_t getline(char **lineptr, size_t *n, FILE *stream); 




//read line function __________________________________________________________________ 
char *read_line(void) {
  
  char *buf = NULL;
  size_t bufsize = 0;
  printf("ProjSh$ ");
  //fflush(stdout); //debugging purposes

  if(getline(&buf, &bufsize, stdin) == -1) {
      buf = NULL;
      if (feof(stdin)) {
          printf("[End of File]\n"); }
      else { perror("getline"); }
  free(buf);
  return NULL;
  }

return buf;
}

//token function ______________________________________________________________________
char **split_line(char *line) {
  size_t position = 0;
  size_t bufsize = BUFSIZ;

  char **tokens = malloc(BUFSIZ * sizeof *tokens);
  if (!tokens) {
      perror("malloc");
      exit(EXIT_FAILURE);

  }
  char *token = strtok(line, DEL);
  while (token != NULL) {
      tokens[position++] = token;
          if (position >= bufsize) {
              bufsize *= 2;
              tokens = realloc(tokens, bufsize * sizeof(*tokens));
              if (!tokens) {
                  perror("realloc");
                  exit(EXIT_FAILURE);
              }
          }
          token = strtok(NULL, DEL);
    }
  tokens[position] = NULL; // sentinel value
  return tokens;

}

//built-in functions: exit and cd ____________________________________________________
typedef struct s_builtin {

 const char *builtin_name;
  int (*foo)(char **);
}   t_builtin;

//the exit built-in command
int shpj_exit(char **args) {
        (void)args;
        printf("e x i t i n g :)\n");
        fflush(stdout); //debugging
        exit(0);
}

//global built-in functions: 
t_builtin g_builtin[] =
{       
        {.builtin_name="exit", .foo = shpj_exit },
        {NULL, NULL} //to stop the loop 
//      {.builtin_name="cd", .foo=cd};
//      {.builtin_name="NULL", .foo=NULL};

};

//exec function ______________________________________________________________________
void exec(char **args) {
 //is it a builtin function? call it else --> fork+execvp+wait
 int i = 0;
 const char *curr;
 while((curr = g_builtin[i].builtin_name)) {
        printf("[DEBUGGING] Checking builtin: %s\n", curr);
        if(!strcmp(curr, args[0])) {
                printf("[DEBUGGING] Found builtin: %s, calling function\n", curr);
                g_builtin[i].foo(args); //calls the builin
                printf("[DEBUGGING] Returned from builtin\n");
                return;
        }
        ++i; //not a built-in
   }

//      child(args); //fork --> exec 
        printf("[DEBUGGING] end of exec function.\n");
}


//main function ___________________________________________________________________________

int main(int ac, char **av) {

  char *line;   

  while(1) {
    
//get line
    line = read_line(); //call to read_line() function
      if (line == NULL) {
        break; 
      }
    printf("%s\n", line); //outputs what the user typed

//splitting for tokens
    char **args = split_line(line);
        //debugging purposes: 
        for (int i=0; args[i]; ++i) {
                printf("here:%s\n", args[i]);
        }

//calling exec() function
  exec(args);

//free memory 
    free(args);
    free(line);



//i couldn't tell if this was to get the line or read the line, i went ahead and wrote
//code to get a line just using a read line. lol :) 
---------------your code:----------------------------
    //gets input from user using fgets()
    char * read_line(void) {
    int position = 0;
    char * buffer = malloc(sizeof(char) * BUFF_SIZE);
    int num;
    }
    //If buffer is exceeded, throw error
    if(!buffer){
      fprintf(stderr, "shpj: allocation error\n");
        exit(EXIT_FAILURE);

  //If buffer is not empty, trim the buffer to remove the newline
  //////
  
  //If buffer is empty, return null
  if(fgets(buffer, BUFF_SIZE, stdin)==NULL){ return NULL;}

  return buffer;
  }
--------------------------------------------------------




//step 3: exec (child processes)

  //check if exit command 
    //if exit... 
    //else store/execute
        //parsing input via tokens

//the built-in exit commands: 
  //exit 
  //cd 

//for external commands use fork()
  //in the child run the commands 
//the parent wait()

}

return EXIT_SUCCESS;
}



  
