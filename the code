#include<stdio.h> 
#include<stdlib.h>
#include<string.h> 
#include<unistd.h>
#include<sys/wait.h> 

//uncomment if getline doesn't work on your machine: 
//#define _GNU_SOURCE

#define DEL "\n\t \v\f\r" //all types of whitespaces 

//uncomment if getline doesn't work on your machine: 
ssize_t getline(char **lineptr, size_t *n, FILE *stream); 


--------------------IGNORE-------------------------------------------
#define MAX_LINE 1024     //max length
#define MAX_ARGS 11      //max num of space-separated tokens
#define TOKEN_SZE 80    //token size no > 80
#define BUFF_SIZE 1024; 

//shpj = shell project (tehe) 
---------------------------------------------------------------------

//function to read line(s): 
char *read_line(void) {
  
  char *buf = NULL;
  size_t bufsize = 0;
  printf("ProjSh$ ");
  //fflush(stdout); //debugging purposes

  if(getline(&buf, &bufsize, stdin) == -1) {
      buf = NULL;
      if (feof(stdin)) {
          printf("[End of File]\n"); }
      else { perror("getline"); }
  free(buf);
  return NULL;
  }

return buf;
}

//token function [av]
char **split_line(char *line) {
  size_t position = 0;
  size_t bufsize = BUFSIZ;

  char **tokens = malloc(BUFSIZ * sizeof *tokens);
  if (!tokens) {
      perror("malloc");
      exit(EXIT_FAILURE);

  }
  char *token = strtok(line, DEL);
  while (token != NULL) {
      tokens[position++] = token;
          if (position >= bufsize) {
              bufsize *= 2;
              tokens = realloc(tokens, bufsize * sizeof(*tokens));
              if (!tokens) {
                  perror("realloc");
                  exit(EXIT_FAILURE);
              }
          }
          token = strtok(NULL, DEL);
    }
  tokens[position] = NULL; // sentinel value
  return tokens;

}

//main function

int main(int ac, char **av) {

  char *line;   

  while(1) {
    
//get line
    line = read_line(); //call to read_line() function
      if (line == NULL) {
        break; 
      }
    printf("%s\n", line); //outputs what the user typed

//splitting for tokens
    char **args = split_line(line);
        //debugging purposes: 
        for (int i=0; args[i]; ++i) {
                printf("here:%s\n", args[i]);
        }
    free(args);
    free(line);



//i couldn't tell if this was to get the line or read the line, i went ahead and wrote
//code to get a line just using a read line. lol :) 
---------------your code:----------------------------
    //gets input from user using fgets()
    char * read_line(void) {
    int position = 0;
    char * buffer = malloc(sizeof(char) * BUFF_SIZE);
    int num;
    }
    //If buffer is exceeded, throw error
    if(!buffer){
      fprintf(stderr, "shpj: allocation error\n");
        exit(EXIT_FAILURE);

  //If buffer is not empty, trim the buffer to remove the newline
  //////
  
  //If buffer is empty, return null
  if(fgets(buffer, BUFF_SIZE, stdin)==NULL){ return NULL;}

  return buffer;
  }
--------------------------------------------------------




//step 3: exec (child processes)

  //check if exit command 
    //if exit... 
    //else store/execute
        //parsing input via tokens

//the built-in exit commands: 
  //exit 
  //cd 

//for external commands use fork()
  //in the child run the commands 
//the parent wait()

}

return EXIT_SUCCESS;
}



  
